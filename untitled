		checkObjAccessibility: function () {
			//GLADYSHEV
			startPoint            = game.myMapObjects[game.castleX][game.castleY+1];
			nonAccessible         = false;
			//10 castle entrance, 4 
			visitableElements     = [10];
			pointsToCheck         = [];
			ci                    = 0;
			for (i=0; i<config.sizeMapX; i++){
				for (j=0; j<config.sizeMapX; j++){
					ci = ci + 1; //ci is common iterator for objects
					//first we check whether myMapObjects has something
					//then add AND condition
					//that myMapObjects is NOT in the list of nonVisitableElements
					if (inArray(visitableElements, game.myMapObjects[i][j])) {
						console.log("the element code is "+game.myMapObjects[i][j]+" in this loc "+i+"; "+j);
						pointsToCheck.push({"coord":[i,j]});
					}
				}
			}
			console.log(pointsToCheck);
			pfmap           = game.prepareMap();
			numberOfPoints  = pointsToCheck.length;
			console.log("---");
			for (np=0; np<numberOfPoints; np++) {
				console.log(pointsToCheck[np]);
				resPathMap = game.genPathMap(pfmap)
			}
			console.log("---");
		},
		prepareMap : function () {
			preparedMap = game.myMapObjects;
			for (i=0; i<config.sizeMapX; i++){
				for (j=0; j<config.sizeMapX; j++){
					if (game.myMapObjects[i][j] == 10){
						preparedMap[i][j] = 1;
					}
					if (game.myMapObjects[i][j] == 0){
						preparedMap[i][j] = 1;
					}
					if (game.myMapObjects[i][j] !== 0 && game.myMapObjects[i][j] !== 10) {
						preparedMap[i][j] = 0;
					}
				}
			}
			return preparedMap;
		},
		genPathMap : function (gen_pfmap) {
			console.log("call gen path map");
			console.log(gen_pfmap);
			neighbor_offsets = [[0, 1], [1, 0], [0, -1], [-1, 0]];
			pathMap          = [];
			for (i=0;i<config.sizeMapX;i++) {
				pathMap.push([]);
			}
			for (i = 0; i < config.sizeMapX; i++) {
				for (j = 0; j < config.sizeMapY; j++) {
					pathMap[i][j]=0;
				}
			}
			nodeList         = [[game.heroX, game.heroY]];
			pathMap[game.heroX][game.heroY]  =  1;
			node_list       = [[game.heroX][game.heroY]];
			for (node in node_list){
				//print("---new-node---")
				score = pathMap[node[0]][node[1]]
				//print(score)
				for (neighbor_offset in neighbor_offsets){
					//print("run over neighbor offsets")
					neighbor_x = node[0]*1+neighbor_offset[0]*1;
					neighbor_y = node[1]*1+neighbor_offset[1]*1;
					if (neighbor_x < 0 ||
					   neighbor_y < 0 ||
					   neighbor_x >= config.sizeMapX ||
					   neighbor_y >= config.sizeMapY){
						console.log("out of borders - we can not move here "+neighbor_x+";"+neighbor_y);
						continue
					}
					if (gen_pfmap[neighbor_x][neighbor_y] == 0){
						console.log("not travelable - we can not move here "+neighbor_x+";"+neighbor_y);
						continue
					}
					if (gen_pfmap[neighbor_x][neighbor_y] == 1){
						console.log("travelable - we could move there " + neighbor_x + ";" + neighbor_y);
						if (neighbor_x == start[0] && neighbor_y == start[1]) {
							console.log("we found the target!");
							pathMap[neighbor_x][neighbor_y] = score*1 + 1
						} else {
							if (pathMap[neighbor_x][neighbor_y] == 0){
								console.log("can move here "+neighbor_x+";"+neighbor_y);
								node_list.push([neighbor_x, neighbor_y]);
								pathMap[neighbor_x][neighbor_y] = score*1 + 1;
								continue
							} else {
								console.log("we already have been here " + neighbor_x + ";" + neighbor_y);
								continue
							}
						}
					}
				}
				//print("-----")
				console.log("---the pathMap----");
				console.log(pathMap);
				return pathMap;
			}
			return 0;
		},
